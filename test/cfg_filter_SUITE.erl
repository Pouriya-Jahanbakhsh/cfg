%% Auto-generated by https://github.com/Pouriya-Jahanbakhsh/estuff
%% -----------------------------------------------------------------------------
-module(cfg_filter_SUITE).
-author('pouriya.jahanbakhsh@gmail.com').
%% -----------------------------------------------------------------------------
%% Exports:

%% ct callbacks:
-export([init_per_suite/1
        ,end_per_suite/1
        ,all/0
        ,init_per_testcase/2
        ,end_per_testcase/2]).

%% Testcases:
-export(['1'/1
        ,'2'/1
        ,'3'/1
        ,'4'/1
        ,'5'/1
        ,'6'/1
        ,'7'/1
        ,'8'/1
        ,'9'/1
        ,'10'/1]).

-export([filter/1, filter/2, filter_1/1]).

%% -----------------------------------------------------------------------------
%% Records & Macros & Includes:

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").

%% -----------------------------------------------------------------------------
%% ct callbacks:


all() ->
    ToInteger =
        fun
            ({Func, 1}) ->
                try
                    erlang:list_to_integer(erlang:atom_to_list(Func))
                catch
                    _:_ ->
                        0
                end;
            (_) -> % Arity > 1 | Arity == 0
                0
        end,
    % contains 0 for other functions:
    Ints = [ToInteger(X) || X <- ?MODULE:module_info(exports)],
    % 1, 2, ...
    PosInts = lists:sort([Int || Int <- Ints, Int > 0]),
    % '1', '2', ...
    [erlang:list_to_atom(erlang:integer_to_list(X)) || X <- PosInts].


init_per_suite(Cfg) ->
    application:start(sasl),
    Cfg.


end_per_suite(Cfg) ->
    application:stop(sasl),
    Cfg.


init_per_testcase(_TestCase, Cfg) ->
    Cfg.


end_per_testcase(_TestCase, _Cfg) ->
    ok.

%% -----------------------------------------------------------------------------
%% Test cases:


'1'(Cfg) ->
    _ = Cfg,
    ok.


'2'(Cfg) ->
    _ = Cfg,
    ?assertMatch({ok, [{k, v}], []}, cfg:filter([{k, v}], [{k, any}])),
    ?assertMatch({ok, [{k, 1}], []}, cfg:filter([{k, 1}], [{k, number}])),
    ?assertMatch({ok, [{k, 1.0}], []}, cfg:filter([{k, 1.0}], [{k, number}])),
    ?assertMatch({ok, [{k, 1}], []}, cfg:filter([{k, 1}], [{k, integer}])),
    ?assertMatch({ok, [{k, 1.0}], []}, cfg:filter([{k, 1.0}], [{k, float}])),
    ?assertMatch({ok, [{k, v}], []}, cfg:filter([{k, v}], [{k, atom}])),
    ?assertMatch({ok, [{k, true}], []}, cfg:filter([{k, true}], [{k, boolean}])),
    ?assertMatch({ok, [{k, false}], []}, cfg:filter([{k, false}], [{k, boolean}])),
    ?assertMatch({ok, [{k, <<"foo">>}], []}, cfg:filter([{k, <<"foo">>}], [{k, binary}])),
    ?assertMatch({ok, [{k, [1,2,3,4,5]}], []}, cfg:filter([{k, [1,2,3,4,5]}], [{k, list}])),
    ?assertMatch({ok, [{k, [{k2, v2}]}], []}, cfg:filter([{k, [{k2, v2}]}], [{k, proplist}])),
    ?assertMatch({error, {_, #{allowed_type := proplist}}}, cfg:filter([{k, 1}], [{k, proplist}])),
    ?assertMatch({error, {_, #{allowed_type := atom}}}, cfg:filter([{k, [{k2, v2}]}], [{k, atom}])),
    
    ?assertMatch({ok, [{k, v}], []}, cfg:filter([{k, v}], [{k, '_', oops}])),
    ?assertMatch({ok, [{k, default}], []}, cfg:filter([], [{k, any, default}])),
    ?assertMatch({error, {_, #{reason := not_found}}}, cfg:filter([], [{k, any}])),
    
    ?assertMatch({ok, [{k, 1}], []}, cfg:filter([{k, 1}], [{k, {one_of, [1,2,3]}}])),
    ?assertMatch({ok, [{k, 2}], []}, cfg:filter([{k, 2}], [{k, {one_of, [1,2,3]}}])),
    ?assertMatch({ok, [{k, 3}], []}, cfg:filter([{k, 3}], [{k, {one_of, [1,2,3]}}])),
    ?assertMatch({error, {_, #{allowed_values := [1,2,3]}}}, cfg:filter([{k, 4}], [{k, {one_of, [1,2,3]}}])),
    ?assertMatch({error, {_, _}}, cfg:filter([{k, 4}], [{k, {one_of, [1,2|3]}}])),
    
    ?assertMatch({ok, [{k,v}], []}, cfg:filter([{k, {ok, v}}], [{k, {f, fun filter/1}}])),
    ?assertMatch({ok, [{k,v}], []}, cfg:filter([{k, {ok, v}}], [{k, {f, fun filter/2}}])),
    ?assertMatch({ok, [{k,v2}], []}, cfg:filter([{k, {ok, v2}}], [{k, {f, fun filter/2}}])),
    
    ?assertMatch({ok, [{k,ok}], []}, cfg:filter([{k, ok}], [{k, {f, fun filter/1}}])),
    ?assertMatch({ok, [{k,true}], []}, cfg:filter([{k, true}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{reason := bad_value}}}, cfg:filter([{k, false}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{previous_error := {reason, #{}}}}}, cfg:filter([{k, {error, {reason, #{}}}}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{returned_value := unknown_ret}}}, cfg:filter([{k, unknown_ret}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{exception := oops}}}, cfg:filter([{k, {exception, oops}}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{arity := 3}}}, cfg:filter([{k, v}], [{k, {f, fun(_, _, _) -> ok end}}])),
    ?assertMatch({error, {_, #{f := bad_fun}}}, cfg:filter([{k, v}], [{k, {f, bad_fun}}])),
    
    ?assertMatch({ok, [{k, <<"v">>}], []}, cfg:filter([{k, v}], [{k, atom_to_binary}])),
    ?assertMatch({error, {_, #{bif := atom_to_binary}}}, cfg:filter([{k, 1}], [{k, atom_to_binary}])),
    ?assertMatch({ok, [{k, "v"}], []}, cfg:filter([{k, v}], [{k, atom_to_list}])),
    ?assertMatch({error, {_, #{bif := atom_to_list}}}, cfg:filter([{k, 1}], [{k, atom_to_list}])),
    
    
    ?assertMatch({ok, [{k,v}], []}, cfg:filter([{k, {ok, v}}], [{k, {mf, {?MODULE, filter_1}}}])),
    ?assertMatch({ok, [{k,v}], []}, cfg:filter([{k, {ok, v}}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({ok, [{k,v2}], []}, cfg:filter([{k, {ok, v2}}], [{k, {mf, {?MODULE, filter}}}])),
    
    ?assertMatch({ok, [{k,ok}], []}, cfg:filter([{k, ok}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({ok, [{k,true}], []}, cfg:filter([{k, true}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{reason := bad_value}}}, cfg:filter([{k, false}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{previous_error := {reason, #{}}}}}, cfg:filter([{k, {error, {reason, #{}}}}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{returned_value := unknown_ret}}}, cfg:filter([{k, unknown_ret}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{exception := oops}}}, cfg:filter([{k, {exception, oops}}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{arity := 0}}}, cfg:filter([{k, v}], [{k, {mf, {?MODULE, unknown_function}}}])),
    ?assertMatch({error, {_, #{mf := bad_mf}}}, cfg:filter([{k, v}], [{k, {mf, bad_mf}}])),
    
    
    ?assertMatch({ok, [{k, [{k2, v2}]}], []}, cfg:filter([{k, [{k2, v2}]}], [{k, {proplist, [{k2, atom}]}}])),
    ?assertMatch({ok, [{k, [{k2, v2}]}], []}, cfg:filter([{k, [{k2, v2}]}], [{k, {proplist, [{k2, atom}]}, default}])),
    ?assertMatch({ok, [{k, [{k2, v2}, {k3, default}]}], [{k, [{k4, v4}]}]}, cfg:filter([{k, [{k2, v2}, {k4, v4}]}], [{k, {proplist, [{k2, atom}, {k3, any, default}]}}])),
    ?assertMatch({ok, [{k, [{k2, v2}, {k3, default}]}], [{k, [{k4, v4}]}]}, cfg:filter([{k, [{k2, v2}, {k4, v4}]}], [{k, {proplist, [{k2, atom}, {k3, any, default}]}, default}])),
    
    ?assertMatch(
        {ok, [{k, [10, 20, 30, 40]}], []},
        cfg:filter(
            [{k, [10, 20, 30, 40]}],
            [
                {
                    k,
                    {
                        list,
                        {
                            f,
                            fun
                                (X) when X rem 10 == 0 ->
                                    true;
                                (_) ->
                                    false
                            end
                        }
                    }
                }
            ]
        )
    ),
    ?assertMatch(
        {error, {_, #{reason := bad_value}}},
        cfg:filter(
            [{k, [10, 20, 35, 40]}],
            [
                {
                    k,
                    {
                        list,
                        {
                            f,
                            fun
                                (X) when X rem 10 == 0 ->
                                    true;
                                (_) ->
                                    false
                            end
                        }
                    }
                }
            ]
        )
    ),
    ?assertMatch(
        {ok, [{k, [[{k, v}]]}], [{k, [{k2, v2}]}]},
        cfg:filter(
            [{k, [[{k, v}, {k2, v2}]]}],
            [{k, {list, {proplist, [{k, any}]}}}]
        )
    ),
    ?assertMatch(
        {error, {_, #{list := 2}}},
        cfg:filter([{k, 2}], [{k, {list, any}}])
    ),
    
    
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, 10}}])),
    ?assertMatch({error, {_, #{allowed_size := 11}}}, cfg:filter([{k, 10}], [{k, {size, 11}}])),
    ?assertMatch({error, {_, #{allowed_types := _}}}, cfg:filter([{k, atom}], [{k, {size, 11}}])),
    
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {min, 9}}}])),
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {min, 10}}}])),
    ?assertMatch({error, {_, #{allowed_min_size := 11}}}, cfg:filter([{k, 10}], [{k, {size, {min, 11}}}])),
    ?assertMatch({error, {_, #{allowed_types := _}}}, cfg:filter([{k, atom}], [{k, {size, {min, 10}}}])),
    
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {max, 11}}}])),
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {max, 10}}}])),
    ?assertMatch({error, {_, #{allowed_max_size := 9}}}, cfg:filter([{k, 10}], [{k, {size, {max, 9}}}])),
    ?assertMatch({error, {_, #{allowed_types := _}}}, cfg:filter([{k, atom}], [{k, {size, {max, 10}}}])),
    
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {9, 11}}}])),
    ?assertMatch({ok, [{k, 9}], []}, cfg:filter([{k, 9}], [{k, {size, {9, 11}}}])),
    ?assertMatch({ok, [{k, 11}], []}, cfg:filter([{k, 11}], [{k, {size, {9, 11}}}])),
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {min, 10}}}])),
    ?assertMatch({error, {_, #{allowed_min_size := 9}}}, cfg:filter([{k, 8}], [{k, {size, {9, 11}}}])),
    ?assertMatch({error, {_, #{allowed_max_size := 11}}}, cfg:filter([{k, 12}], [{k, {size, {9, 11}}}])),
    ?assertMatch({error, {_, #{allowed_types := _}}}, cfg:filter([{k, atom}], [{k, {size, {9, 11}}}])),
    
    ?assertMatch({error, {_, #{size_value := bad_size}}}, cfg:filter([{k, atom}], [{k, {size, bad_size}}])),
    
    ?assertMatch({ok, [{k, 3.14}], []}, cfg:filter([{k, 3.14}], [{k, {size, {min, 1}}}])),
    ?assertMatch({ok, [{k, 3.14}], []}, cfg:filter([{k, 3.14}], [{k, {size, {max, 5.0}}}])),
    
    ?assertMatch({ok, [{k, [1, 2, 3]}], []}, cfg:filter([{k, [1, 2, 3]}], [{k, {size, 3}}])),
    ?assertMatch({error, {_, #{allowed_types := _}}}, cfg:filter([{k, [1, 2 | 3]}], [{k, {size, 3}}])),
    ?assertMatch({ok, [{k, <<"ABC">>}], []}, cfg:filter([{k, <<"ABC">>}], [{k, {size, 3}}])),
    
    ?assertMatch({ok, [{k, <<"ABC">>}], []}, cfg:filter([{k, <<"ABC">>}], [{k, {'&', [binary, {size, 3}]}}])),
    ?assertMatch({error, {_, #{allowed_size := 4}}}, cfg:filter([{k, <<"ABC">>}], [{k, {'and', [binary, {size, 4}]}}])),
    ?assertMatch({error, {_, _}}, cfg:filter([{k, <<"ABC">>}], [{k, {'&', bad_and}}])),
    
    ?assertMatch({ok, [{k, [1, 2.0, '3']}], []}, cfg:filter([{k, [1, 2.0, '3']}], [{k, {list, {'|', [integer, float, atom]}}}])),
    ?assertMatch({error, {_, _}}, cfg:filter([{k, [1, 2.0, '3', <<"4">>]}], [{k, {list, {'or', [integer, float, atom]}}}])),
    ?assertMatch({error, {_, _}}, cfg:filter([{k, <<"ABC">>}], [{k, {'|', bad_or}}])),
    
    ?assertMatch({error, {_, #{key_filter := unknown_key_filter}}}, cfg:filter([{k, <<"ABC">>}], [{k, unknown_key_filter}])),
    ?assertMatch({error, {_, #{filter := unknown_filter}}}, cfg:filter([{k, <<"ABC">>}], [unknown_filter])),
    ?assertMatch({error, {_, #{filters := unknown_filters}}}, cfg:filter([{k, <<"ABC">>}], unknown_filters)),
    
    
    ok.



'3'(Cfg) ->
    _ = Cfg,
    ok.



'4'(Cfg) ->
    _ = Cfg,
    ok.



'5'(Cfg) ->
    _ = Cfg,
    ok.



'6'(Cfg) ->
    _ = Cfg,
    ok.



'7'(Cfg) ->
    _ = Cfg,
    ok.



'8'(Cfg) ->
    _ = Cfg,
    ok.



'9'(Cfg) ->
    _ = Cfg,
    ok.



'10'(Cfg) ->
    _ = Cfg,
    ok.


filter({exception, X}) ->
    erlang:error(X);

filter(X) ->
    X.


filter_1({exception, X}) ->
    erlang:error(X);

filter_1(X) ->
    X.


filter(_, {exception, X}) ->
    erlang:error(X);

filter(_, X) ->
    X.