%% Auto-generated by https://github.com/Pouriya-Jahanbakhsh/estuff
%% -----------------------------------------------------------------------------
-module(cfg_filter_SUITE).
-author('pouriya.jahanbakhsh@gmail.com').
%% -----------------------------------------------------------------------------
%% Exports:

%% ct callbacks:
-export([init_per_suite/1
        ,end_per_suite/1
        ,all/0
        ,init_per_testcase/2
        ,end_per_testcase/2]).

%% Testcases:
-export(['1'/1
        ,'2'/1
        ,'3'/1
        ,'4'/1
        ,'5'/1
        ,'6'/1
        ,'7'/1
        ,'8'/1
        ,'9'/1
        ,'10'/1]).

-export([filter/1, filter/2, filter_1/1]).

%% -----------------------------------------------------------------------------
%% Records & Macros & Includes:

-include_lib("common_test/include/ct.hrl").
-include_lib("eunit/include/eunit.hrl").

%% -----------------------------------------------------------------------------
%% ct callbacks:


all() ->
    ToInteger =
        fun
            ({Func, 1}) ->
                try
                    erlang:list_to_integer(erlang:atom_to_list(Func))
                catch
                    _:_ ->
                        0
                end;
            (_) -> % Arity > 1 | Arity == 0
                0
        end,
    % contains 0 for other functions:
    Ints = [ToInteger(X) || X <- ?MODULE:module_info(exports)],
    % 1, 2, ...
    PosInts = lists:sort([Int || Int <- Ints, Int > 0]),
    % '1', '2', ...
    [erlang:list_to_atom(erlang:integer_to_list(X)) || X <- PosInts].


init_per_suite(Cfg) ->
    application:start(sasl),
    Cfg.


end_per_suite(Cfg) ->
    application:stop(sasl),
    Cfg.


init_per_testcase(_TestCase, Cfg) ->
    Cfg.


end_per_testcase(_TestCase, _Cfg) ->
    ok.

%% -----------------------------------------------------------------------------
%% Test cases:


'1'(Cfg) ->
    _ = Cfg,
    ok.


'2'(Cfg) ->
    _ = Cfg,
    ?assertMatch({ok, [{k, v}], []}, cfg:filter([{k, v}], [{k, any}])),
    ?assertMatch({ok, [{k, 1}], []}, cfg:filter([{k, 1}], [{k, number}])),
    ?assertMatch({ok, [{k, 1.0}], []}, cfg:filter([{k, 1.0}], [{k, number}])),
    ?assertMatch({ok, [{k, 1}], []}, cfg:filter([{k, 1}], [{k, integer}])),
    ?assertMatch({ok, [{k, 1.0}], []}, cfg:filter([{k, 1.0}], [{k, float}])),
    ?assertMatch({ok, [{k, v}], []}, cfg:filter([{k, v}], [{k, atom}])),
    ?assertMatch({ok, [{k, true}], []}, cfg:filter([{k, true}], [{k, boolean}])),
    ?assertMatch({ok, [{k, false}], []}, cfg:filter([{k, false}], [{k, boolean}])),
    ?assertMatch({ok, [{k, <<"foo">>}], []}, cfg:filter([{k, <<"foo">>}], [{k, binary}])),
    ?assertMatch({ok, [{k, [1,2,3,4,5]}], []}, cfg:filter([{k, [1,2,3,4,5]}], [{k, list}])),
    ?assertMatch({ok, [{k, [{k2, v2}]}], []}, cfg:filter([{k, [{k2, v2}]}], [{k, proplist}])),
    ?assertMatch({error, {_, #{previous_error := #{allowed_type := proplist}}}}, cfg:filter([{k, 1}], [{k, proplist}])),
    ?assertMatch({error, {_, #{previous_error := #{allowed_type := atom}}}}, cfg:filter([{k, [{k2, v2}]}], [{k, atom}])),
    
    ?assertMatch({ok, [{k, v}], []}, cfg:filter([{k, v}], [{k, '_', oops}])),
    ?assertMatch({ok, [{k, default}], []}, cfg:filter([], [{k, any, default}])),
    ?assertMatch({error, {_, #{reason := not_found}}}, cfg:filter([], [{k, any}])),
    
    ?assertMatch({ok, [{k, 1}], []}, cfg:filter([{k, 1}], [{k, {one_of, [1,2,3]}}])),
    ?assertMatch({ok, [{k, 2}], []}, cfg:filter([{k, 2}], [{k, {one_of, [1,2,3]}}])),
    ?assertMatch({ok, [{k, 3}], []}, cfg:filter([{k, 3}], [{k, {one_of, [1,2,3]}}])),
    ?assertMatch({error, {_, #{previous_error := #{allowed_values := [1,2,3]}}}}, cfg:filter([{k, 4}], [{k, {one_of, [1,2,3]}}])),
    
    ?assertMatch({ok, [{k,v}], []}, cfg:filter([{k, {ok, v}}], [{k, {f, fun filter/1}}])),
    ?assertMatch({ok, [{k,v}], []}, cfg:filter([{k, {ok, v}}], [{k, {f, fun filter/2}}])),
    ?assertMatch({ok, [{k,v2}], []}, cfg:filter([{k, {ok, v2}}], [{k, {f, fun filter/2}}])),
    
    ?assertMatch({ok, [{k,ok}], []}, cfg:filter([{k, ok}], [{k, {f, fun filter/1}}])),
    ?assertMatch({ok, [{k,true}], []}, cfg:filter([{k, true}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{previous_error := #{reason := bad_value}}}}, cfg:filter([{k, false}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{previous_error := #{previous_error := {reason, #{}}}}}}, cfg:filter([{k, {error, {reason, #{}}}}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{previous_error := #{returned_value := unknown_ret}}}}, cfg:filter([{k, unknown_ret}], [{k, {f, fun filter/1}}])),
    ?assertMatch({error, {_, #{previous_error := #{exception := oops}}}}, cfg:filter([{k, {exception, oops}}], [{k, {f, fun filter/1}}])),
    
    ?assertMatch({ok, [{k, <<"v">>}], []}, cfg:filter([{k, v}], [{k, atom_to_binary}])),
    ?assertMatch({error, {_, #{previous_error := #{bif := atom_to_binary}}}}, cfg:filter([{k, 1}], [{k, atom_to_binary}])),
    ?assertMatch({ok, [{k, "v"}], []}, cfg:filter([{k, v}], [{k, atom_to_list}])),
    ?assertMatch({error, {_, #{previous_error := #{bif := atom_to_list}}}}, cfg:filter([{k, 1}], [{k, atom_to_list}])),
    
    ?assertMatch({ok, [{k, #{}}], []}, cfg:filter([{k, []}], [{k, proplist_to_map}])),
    ?assertMatch({error, _}, cfg:filter([{k, 1}], [{k, proplist_to_map}])),
    
    
    ?assertMatch({ok, [{k,v}], []}, cfg:filter([{k, {ok, v}}], [{k, {mf, {?MODULE, filter_1}}}])),
    ?assertMatch({ok, [{k,v}], []}, cfg:filter([{k, {ok, v}}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({ok, [{k,v2}], []}, cfg:filter([{k, {ok, v2}}], [{k, {mf, {?MODULE, filter}}}])),
    
    ?assertMatch({ok, [{k,ok}], []}, cfg:filter([{k, ok}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({ok, [{k,true}], []}, cfg:filter([{k, true}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{previous_error := #{reason := bad_value}}}}, cfg:filter([{k, false}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{previous_error := #{previous_error := {reason, #{}}}}}}, cfg:filter([{k, {error, {reason, #{}}}}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{previous_error := #{returned_value := unknown_ret}}}}, cfg:filter([{k, unknown_ret}], [{k, {mf, {?MODULE, filter}}}])),
    ?assertMatch({error, {_, #{previous_error := #{exception := oops}}}}, cfg:filter([{k, {exception, oops}}], [{k, {mf, {?MODULE, filter}}}])),
    
    
    ?assertMatch({ok, [{k, [{k2, v2}]}], []}, cfg:filter([{k, [{k2, v2}]}], [{k, {proplist, [{k2, atom}]}}])),
    ?assertMatch({ok, [{k, [{k2, v2}]}], []}, cfg:filter([{k, [{k2, v2}]}], [{k, {proplist, [{k2, atom}]}, default}])),
    ?assertMatch({ok, [{k, [{k2, v2}, {k3, default}]}], [{k, [{k4, v4}]}]}, cfg:filter([{k, [{k2, v2}, {k4, v4}]}], [{k, {proplist, [{k2, atom}, {k3, any, default}]}}])),
    ?assertMatch({ok, [{k, [{k2, v2}, {k3, default}]}], [{k, [{k4, v4}]}]}, cfg:filter([{k, [{k2, v2}, {k4, v4}]}], [{k, {proplist, [{k2, atom}, {k3, any, default}]}, default}])),
    
    ?assertMatch({ok, [{k, [{k2, [{k3, v3}]}]}], []}, cfg:filter([{k, [{k2, [{k3, v3}]}]}], [{k, {proplist, [{k2, {proplist, [{k3, atom}]}}]}, default}])),
    ?assertMatch({ok, [{k, [{k2, [{k3, v3}]}]}], []}, cfg:filter([{k, [{k2, [{k3, v3}]}]}], [{k, {proplist, [{k2, {proplist, [{k3, atom}]}}]}, default}])),
    
    ?assertMatch(
        {ok, [{k, [10, 20, 30, 40]}], []},
        cfg:filter(
            [{k, [10, 20, 30, 40]}],
            [
                {
                    k,
                    {
                        list,
                        {
                            f,
                            fun
                                (X) when X rem 10 == 0 ->
                                    true;
                                (_) ->
                                    false
                            end
                        }
                    }
                }
            ]
        )
    ),
    ?assertMatch(
        {error, {_, #{previous_error := #{reason := bad_value}}}},
        cfg:filter(
            [{k, [10, 20, 35, 40]}],
            [
                {
                    k,
                    {
                        list,
                        {
                            f,
                            fun
                                (X) when X rem 10 == 0 ->
                                    true;
                                (_) ->
                                    false
                            end
                        }
                    }
                }
            ]
        )
    ),
    ?assertMatch(
        {ok, [{k, [[{k, v}]]}], [{k, [{k2, v2}]}]},
        cfg:filter(
            [{k, [[{k, v}, {k2, v2}]]}],
            [{k, {list, {proplist, [{k, any}]}}}]
        )
    ),
    
    
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, 10}}])),
    ?assertMatch({error, {_, #{previous_error := #{allowed_size := 11}}}}, cfg:filter([{k, 10}], [{k, {size, 11}}])),
    ?assertMatch({error, {_, #{previous_error := #{reason := unknown_size}}}}, cfg:filter([{k, atom}], [{k, {size, 11}}])),
    
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {min, 9}}}])),
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {min, 10}}}])),
    ?assertMatch({error, {_, #{previous_error := #{allowed_min_size := 11}}}}, cfg:filter([{k, 10}], [{k, {size, {min, 11}}}])),
    ?assertMatch({error, {_, #{previous_error := #{reason := unknown_size}}}}, cfg:filter([{k, atom}], [{k, {size, {min, 10}}}])),
    
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {max, 11}}}])),
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {max, 10}}}])),
    ?assertMatch({error, {_, #{previous_error := #{allowed_max_size := 9}}}}, cfg:filter([{k, 10}], [{k, {size, {max, 9}}}])),
    ?assertMatch({error, {_, #{previous_error := #{reason := unknown_size}}}}, cfg:filter([{k, atom}], [{k, {size, {max, 10}}}])),
    
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {9, 11}}}])),
    ?assertMatch({ok, [{k, 9}], []}, cfg:filter([{k, 9}], [{k, {size, {9, 11}}}])),
    ?assertMatch({ok, [{k, 11}], []}, cfg:filter([{k, 11}], [{k, {size, {9, 11}}}])),
    ?assertMatch({ok, [{k, 10}], []}, cfg:filter([{k, 10}], [{k, {size, {min, 10}}}])),
    ?assertMatch({error, {_, #{previous_error := #{allowed_min_size := 9}}}}, cfg:filter([{k, 8}], [{k, {size, {9, 11}}}])),
    ?assertMatch({error, {_, #{previous_error := #{allowed_max_size := 11}}}}, cfg:filter([{k, 12}], [{k, {size, {9, 11}}}])),
    ?assertMatch({error, {_, #{previous_error := #{reason := unknown_size}}}}, cfg:filter([{k, atom}], [{k, {size, {9, 11}}}])),
    
    
    ?assertMatch({ok, [{k, 3.14}], []}, cfg:filter([{k, 3.14}], [{k, {size, {min, 1}}}])),
    ?assertMatch({ok, [{k, 3.14}], []}, cfg:filter([{k, 3.14}], [{k, {size, {max, 5.0}}}])),
    
    ?assertMatch({ok, [{k, [1, 2, 3]}], []}, cfg:filter([{k, [1, 2, 3]}], [{k, {size, 3}}])),
    ?assertMatch({error, {_, #{previous_error := #{reason := unknown_size}}}}, cfg:filter([{k, [1, 2 | 3]}], [{k, {size, 3}}])),
    ?assertMatch({ok, [{k, <<"ABC">>}], []}, cfg:filter([{k, <<"ABC">>}], [{k, {size, 3}}])),
    
    ?assertMatch({ok, [{k, <<"ABC">>}], []}, cfg:filter([{k, <<"ABC">>}], [{k, {'&', [binary, {size, 3}]}}])),
    ?assertMatch({error, {_, #{previous_error := #{previous_error := #{allowed_size := 4}}}}}, cfg:filter([{k, <<"ABC">>}], [{k, {'and', [binary, {size, 4}]}}])),
    
    ?assertMatch({ok, [{k, [1, 2.0, '3']}], []}, cfg:filter([{k, [1, 2.0, '3']}], [{k, {list, {'|', [integer, float, atom]}}}])),
    ?assertMatch({error, {_, _}}, cfg:filter([{k, [1, 2.0, '3', <<"4">>]}], [{k, {list, {'or', [integer, float, atom]}}}])),
    
    ?assertMatch({ok, [{value, "foo"}], []}, cfg:filter([{k, value}, {value, foo}], [{{k, atom}, atom_to_list}])),
    ?assertMatch({error, {_, #{previous_error := #{bif := _}}}}, cfg:filter([{k, value}, {value, "foo"}], [{{k, atom}, atom_to_list}])),
    ?assertMatch({error, {_, #{reason := bad_key}}}, cfg:filter([{k, value}, {value, "foo"}], [{{k, atom_to_binary}, atom_to_list}])),
    ?assertMatch({error, {_, #{previous_error := #{reason := not_found}}}}, cfg:filter([{value, "foo"}], [{{k, atom_to_binary}, atom_to_list}])),
    
    ok.



'3'(Cfg) ->
    _ = Cfg,
    ?assertMatch(
        ok,
        cfg:check_filters(
            [{k, atom, default}, {k, atom}, {k, {list, [atom]}}, {k, {'and', [atom, binary]}}, {k, {'or', [atom, binary]}}, {k, {proplist, [{k3, list}]}}, {k, {mf, {m, f}}}, {k, {f, fun erlang:is_number/1}}, {k, {size, 1}}, {k, {size, {min, 1}}}, {k, {size, {max, 1}}}, {k, {size, {1, 2}}}, {k, {one_of, [option]}}, {{k, {one_of, [option]}}, {one_of, [option]}}]
        )
    ),
    ok.



'4'(Cfg) ->
    _ = Cfg,
    ok.



'5'(Cfg) ->
    _ = Cfg,
    ok.



'6'(Cfg) ->
    _ = Cfg,
    ok.



'7'(Cfg) ->
    _ = Cfg,
    ok.



'8'(Cfg) ->
    _ = Cfg,
    ok.



'9'(Cfg) ->
    _ = Cfg,
    ok.



'10'(Cfg) ->
    _ = Cfg,
    ok.


filter({exception, X}) ->
    erlang:error(X);

filter(X) ->
    X.


filter_1({exception, X}) ->
    erlang:error(X);

filter_1(X) ->
    X.


filter(_, {exception, X}) ->
    erlang:error(X);

filter(_, X) ->
    X.